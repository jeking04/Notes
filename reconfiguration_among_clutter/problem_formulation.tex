\documentclass[11pt, oneside]{article}   	% use "amsart" instead of "article" for AMSLaTeX format
\usepackage{geometry}                		% See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   		% ... or a4paper or a5paper or ... 
%\geometry{landscape}                		% Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    		% Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}				% Use pdf, png, jpg, or eps§ with pdflatex; use eps in DVI mode
								% TeX will automatically convert eps --> pdf in pdflatex		
\usepackage{amssymb}

\title{Notes on Reconfiguration Among Clutter}
%\date{}							% Activate to display a given date or no date

\begin{document}
\maketitle
\section*{Introduction}
We wish to build on Mehmet's previous work on reconfiguration among clutter and design a planner which will search the space of possible pushing trajectories to search for a valid grasp.  This document serves  as a scratch pad for formulating the problem.

\section*{Naive Problem Formulation}
\subsection*{Representation of State}
Define the following:
\begin{enumerate}
\item $q_t$ - an $n$-dimensional vector describing the configuration of the arm at time $t$
\item  $O_t^i$ - the 3-dimensional ($x$, $y$, $\theta$) which represents the configuration of obstacle $i$ at time $t$
\item $g_t$ - the 3-dimensional ($x$, $y$, $\theta$) configuration of the goal object at time $t$
\end{enumerate}
Then we can define the state at time $t$, $s_t$, by the vector:
\[ s_t = \left[\begin{array}{ccccc}
q_t & g_t & O_t^1 & ... & O_t^k
\end{array}
\right] \]
which represents the configuration of the arm, the pose of the goal object and the pose of all obstacles at a particular snapshot in time.


\subsection{Representing the Goal}\label{sec:graspability}
We can define the start state as the initial pose of the arm, initial pose of the goal object and the initial pose of all obstacles at a particular snapshot in time.  Defining the goal is less straightforward.  Define $e'_q$ as the pose of the end-effector in goal object frame when the arm is at configuration $q$.  Let $S$ be the set of all poses of the end-effector in goal object frame that result in a valid grasp of the object. Then we can say we which to find any $q$ such that $e'_q \in S$.
\newline\newline
We can define a set of valid grasps using the concept of TSRs.  A TSR is comprised of a matrix, $Bw$, which expresses valid bounds of values for the pose of the end-effector in object frame:
\[ Bw = \left[ \begin{array}{cc}
x_{min} & x_{max} \\
y_{min} & y_{max} \\
z_{min} & z_{max} \\
\alpha_{min} & \alpha_{max} \\
\beta_{min} & \beta_{max} \\
\theta_{min} & \theta_{max} \\
\end{array}\right] \]
Thus for a particular arm configuration $q$ we can first extract the pose of the end-effector in world coordinates, $e_q$, using forward kinematics:
\[ e_q = F(q) \]
We can then convert to the pose of the end-effector in goal object coordinates:
\[ e'_q = e_q g^{-1}\]
where $g$ represents the pose of the goal object in world coordinates.
We can now check that the $x,y,z,\alpha,\beta, \theta$ values represented by the transform fall inside the bounds represented in the TSR.  If so, we have found a valid grasp.  Note: We will need to ensure that the pre shape of the hand during pushing is such that we can close the hand without fear of catching other obstacles.  Otherwise, we will have to do a collision check here.

\subsection*{Action Space}
We want to search over our action space to find a series of actions that, when strung together, will provide a path for the end-effector to grasp the goal object.  We can define an action using the following parameters:
\begin{enumerate}
\item $\theta$ - Specifies the direction of the movement.
\item $d$ - Specifies duration of the movement.
\item $p$ - Represents the pre shape of the hand during the movement.
\item $v$ - The volume of space swept out by the hand during execution of the movement (TODO: should this be limited to just hand, or do we expand to also include the full manipulator)
\end{enumerate}
The cost of an action will be calculated as the length of the action.  We could also add a penalty for the number of objects that come into collision with the hand during action execution.  However, this will guide the planner toward longer but collision free regions of search space, which is not the point.

\subsection*{Forward Planning with Graph Search}
Given a start configuration, we can perform a forward search through the graph by forward simulating each action in the action set.  During simulation we will use the physics model developed by Mehmet to  simulate the movement of any objects that intersect with the swept volume, $v$, during action executing.  Note: Does this use the concept of grasp region? 

There are two cases where an edge (action) will not be added to the graph:
\begin{enumerate}
\item An object is pushed into collision with another object in the scene
\item An object is funneled into the hand as a result of the action.
\end{enumerate}

To determine when the search can be stopped, the configuration of the goal object and the end-effector will be examined to determine whether the goal object has become graspable.  Details of this check were explained in section ~\ref{sec:graspability}.

We will turn the state space into a set of discrete values in each dimension and snap to the center of the nearest grid cell during execution.   This will allow us to recognize when we are exploring a region of state space that we have previously explored.  

We assume that we can precompute the volume, $v$, of space swept by each action and then just apply a transform to use it at runtime.  Encoded in this assumption is the fact that collision with an obstacle will move the obstacle not the manipulator.  In other words, collision with the obstacle will not knock the manipulator off course.

\subsection*{Backward Planning with Graph Search}
Backward simulation of an action is less trivial than forward simulation.  To do this, we can plan the actions in reverse, as though they ended in our current cell.  Initially we don't take into account any possible collisions.  We identify 3 unique scenarios:
\begin{enumerate}
\item If, when the push is backward simulated, there is an obstacle in the footprint, don't add the edge to the graph. This action was not a possible predecessor, as the obstacle in the footprint would have been removed during action execution.
\item If there are no obstacles touching the footprint, we can just add the state that starts the action as a predecessor without changing the pose of any obstacles in the scene.
\item If an obstacle is on the edge of the footprint we add two states: the first represents the obstacle not being moved, the other represents the obstacle being moved.  Here we need to either prove that it could have only been moved in one way, or enumerate all the different ways it could have been moved. 
\end{enumerate}


\subsubsection*{Heuristics}
An obvious choice for heuristic is straight line distance from the end-effector to the goal object.  To make the heuristic admissible, it will have to encode the straight line distance from the closest point of the hand to the goal object and the goal object.  

\section*{Trivial Scenario}
We will first implement and test a fairly trivial scenario to prove the concept and get a feel for scenes where this is useful and possible gotchas.   The following describes the scenario:
\begin{enumerate}
\item Point robot - described by $x$, $y$ location
\item Point obstacles - again described by $x$, $y$ location
\item Goal - The goal is to get the point robot within 1 grid cell in each of the 4 cardinal directions of the goal item - which is a point described by $x$, $y$ location
\item Action set involves movements in only the cardinal directions.
\item If an obstacle is hit during action execution it moves in a direction +90 degrees from the direction of the action by 1 single grid cell.
\end{enumerate}

\section*{Open Questions}
The following is a list of questions to consider:
\begin{enumerate}
\item Do we allow for obstacles that cannot be moved?
\item What coordinate frame should state be represented in? Seems like the end-effector frame could be useful.  Then all obstacles would be represented as distance from the end-effector which could simplify collision checking.
\item Pras mentioned the sorting problem.  Could we use this framework to sort via pushing? Is that interesting/novel.
\end{enumerate}

\end{document}  